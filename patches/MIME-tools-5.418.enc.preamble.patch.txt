diff -ur MIME-tools-5.418.orig/lib/MIME/Body.pm MIME-tools-5.418/lib/MIME/Body.pm
--- MIME-tools-5.418.orig/lib/MIME/Body.pm	Thu Mar 17 22:27:05 2005
+++ MIME-tools-5.418/lib/MIME/Body.pm	Fri Dec 16 19:17:39 2005
@@ -239,6 +239,23 @@
 
 #------------------------------
 
+=item is_encoded [ONOFF]
+
+I<Instance method.>
+If set to yes, no decoding is applied on output. This flag is set
+by MIME::Parser, if the parser runs in decode_bodies(0) mode, so the
+content is handled unmodified.
+
+=cut
+
+sub is_encoded {
+    my ($self, $yesno) = @_;
+    $self->{MB_IsEncoded} = $yesno if (@_ > 1);
+    $self->{MB_IsEncoded};
+}
+
+#------------------------------
+
 =item dup
 
 I<Instance method.>
diff -ur MIME-tools-5.418.orig/lib/MIME/Entity.pm MIME-tools-5.418/lib/MIME/Entity.pm
--- MIME-tools-5.418.orig/lib/MIME/Entity.pm	Wed Sep 28 09:59:20 2005
+++ MIME-tools-5.418/lib/MIME/Entity.pm	Fri Dec 16 19:17:39 2005
@@ -1794,7 +1794,7 @@
 
 	### Preamble:
 	my $preamble = join('', @{ $self->preamble || $DefPreamble });
-	$out->print("$preamble\n") if ($preamble ne '');
+	$out->print("$preamble\n") if ($preamble ne '' or $self->preamble);
 
 	### Parts:
 	my $part;
@@ -1846,14 +1846,20 @@
     my ($self, $out) = @_;
     $out = wraphandle($out || select);             ### get a printable output
 
-    ### Get the encoding, defaulting to "binary" if unsupported:
-    my $encoding = ($self->head->mime_encoding || 'binary');
-    my $decoder = best MIME::Decoder $encoding;
-    $decoder->head($self->head);      ### associate with head, if any
-
-    ### Output the body:
     my $IO = $self->open("r")     || die "open body: $!";
-    $decoder->encode($IO, $out, textual_type($self->head->mime_type) ? 1 : 0)   || die "encoding failed\n";
+    if ( $self->bodyhandle->is_encoded ) {
+      ### Transparent mode: data is already encoded, so no
+      ### need to encode it again
+      my $buf;
+      $out->print($buf) while ($IO->read($buf, 2048));
+    } else {
+      ### Get the encoding, defaulting to "binary" if unsupported:
+      my $encoding = ($self->head->mime_encoding || 'binary');
+      my $decoder = best MIME::Decoder $encoding;
+      $decoder->head($self->head);      ### associate with head, if any
+      $decoder->encode($IO, $out)   || return error "encoding failed";
+    }
+
     $IO->close;
     1;
 }
diff -ur MIME-tools-5.418.orig/lib/MIME/Parser.pm MIME-tools-5.418/lib/MIME/Parser.pm
--- MIME-tools-5.418.orig/lib/MIME/Parser.pm	Thu Mar 17 22:27:05 2005
+++ MIME-tools-5.418/lib/MIME/Parser.pm	Fri Dec 16 19:43:33 2005
@@ -244,6 +244,7 @@
     my $self = shift;
 
     $self->{MP5_DecodeHeaders}   = 0;
+    $self->{MP5_DecodeBodies}    = 1;
     $self->{MP5_Interface}       = {};
     $self->{MP5_ParseNested}     = 'NEST';
     $self->{MP5_Tmp}             = undef;
@@ -476,8 +477,37 @@
 }
 
 
+#------------------------------
+
+=item decode_bodies [YESNO]
+
+I<Instance method.>
+Controls whether the parser should decode entity bodies or not.
+If this is set to a true value (default is false), all entity bodies
+will be kept as-is in the original content-transfer encoding.
+
+To prevent double encoding on the output side MIME::Body->is_encoded
+is set, which tells MIME::Body not to encode the data agin, if encoded
+data is requested. This is in particular useful, when it's importat that
+the content B<must not> be modified, e.g. if you want to calculate
+OpenPGP signatures from it.
+
+B<WARNING>: the semantics change significantly if you parse MIME
+messages with this option set, because MIME::Entity resp. MIME::Body
+*always* see encoded data now, while the default behaviour is
+working with *decoded* data (and encoding it only if you request it).
+You need to decode the data yourself, if you want to have it decoded.
 
+So use this option only if you exactly know, what you're doing, and
+that you're sure, that you really need it.
 
+=cut
+
+sub decode_bodies {
+    my ($self, $yesno) = @_;
+    $self->{MP5_DecodeBodies} = $yesno if (@_ > 1);
+    $self->{MP5_DecodeBodies};
+}
 
 #------------------------------
 #
@@ -799,6 +829,13 @@
 		     "application/octet-stream.");  ### as per RFC-2045
 	$ent->effective_type('application/octet-stream');
 	$decoder = new MIME::Decoder 'binary';
+	$encoding = 'binary';
+    }
+
+    ### Data should be stored encoded / as-is?
+    if ( !$self->decode_bodies ) {
+	$decoder = new MIME::Decoder 'binary';
+	$encoding = 'binary';
     }
 
     ### If desired, sidetrack to troll for UUENCODE:
@@ -825,7 +862,8 @@
     ### Open a new bodyhandle for outputting the data:
     my $body = $self->new_body_for($head) or die "$ME: no body"; # gotta die
     $body->binmode(1) or die "$ME: can't set to binmode: $!"
-        unless textual_type($ent->effective_type);
+        unless textual_type($ent->effective_type) or !$self->decode_bodies;
+    $body->is_encoded(1) if !$self->decode_bodies;
 
     ### Decode and save the body (using the decoder):
     my $DECODED = $body->open("w") or die "$ME: body not opened: $!";
